客户端从浏览器获取到需要渲染的html页面的源代码后：开辟一个 GUI 渲染线程，自上而下解析代码，最后绘制出对应的页面

自上而下渲染解析代码的过程是同步的，但是有些操作也是异步的：

1. 关于 CSS 资源的加载

  + 遇到 <style></style> 内嵌样式，“同步” 交给 GUI 渲染线程解析
  + 遇到 <link> 外链样式，“异步”，开辟一个新的 HTTP 网络请求线程，GUI 不会等待请求的结果，直接向下继续渲染，GUI 渲染线程在所有的同步操作都完成后，再来渲染解析请求回来的结果
  + 遇到 @import 导入式样式，“同步” 开辟一个新的 HTTP 网络请求线程，但是在请求结果返回之前，GUI 渲染线程会被 “阻塞”，不允许其继续向下渲染

2. 遇到 <script></script> 资源请求

  + 默认都是 “同步” 的，开辟一个新的 HTTP 网络请求线程，GUI 渲染线程在请求结果返回前是 “阻塞” 的，等待资源加载完成后，GUI 渲染线程才能继续向下执行
  + async 属性，<script async></script> 首先会开辟一个新的 HTTP 网络请求线程请求资源，于此同时 GUI 渲染线程继续向下渲染，但是一旦资源请求回来后，GUI 渲染线程会马上把加载后来的资源渲染解析
  + defer 属性，<script defer></script> 首先会开辟一个新的 HTTP 网络请求线程请求资源，于此同时 GUI 渲染线程继续向下渲染，但是资源请求回来后，GUI 渲染线程不会马上渲染加载回来的资源，是在 GUI 渲染线程的所有同步操作完成后，再来渲染解析加载回来的资源

3. 遇到 <img> 和 音视频资源
  
  “同步” 开辟一个新的 HTTP 网络请求线程，在请求结果返回前，GUI 渲染线程是 “
  
  阻塞” 的，会等待请求结果返回后，再继续向下渲染解析

**注意**
  webkit浏览器预测解析：chrome 的预加载扫描器 html-preload-scanner 通过扫描节点中的 "src"、"link" 等属性，找到外部链接资源后进行预加载，避免了资源架子啊的等待时间，同样实现了资源的提前加载以及加载和执行的分离


页面渲染步骤：

  1. DOM TREE(DOM树)：自上而下渲染页面，整理好整个页面的 DOM 结构
  2. CSSOM TREE(样式树)：当把所有的样式资源加载回来后，按照引入的 CSS 的顺序，生成样式树
  3. RENDER TREE(渲染树)：把生成的 DOM树 和 CSSOM 树 合并在一起，生成 渲染树(既包含结构也包含样式，dispaly: none 的元素不处理)
  4. Layout 布局/回流/重排：根据生成的渲染树，计算它们在设备视口(viewport)内的确切位置和大小
  5. Painting：按照每一个图层计算绘制步骤，开始绘制页面
  6. Display

前端性能优化：

  + 生成DOM树
    - 减少 DOM 的层级嵌套
    - 不要使用 “非标准” 的标签
  + 生成CSSOM树
    - 尽可能不使用 @import (GUI渲染线程阻塞)
    - 如果 css 代码少，尽可能使用 style内嵌样式(尤其是移动端)
    - 如果使用 link，尽可能把样式资源合并(减少 http 请求次数)
    - 把 link 标签放在 head 标签中(目的是：一加载页面就开始请求资源)
    - css 选择器链短一点(css 选择器渲染从右到左)
  + 其他资源的优化
    - 对于 script，尽可能放置在页面底部(防止其阻塞 GUI 渲染线程)，对于部分 script 使用 async 或 defer，async 是不管 JS 之间的依赖的，defer 是根据引入的顺序
    - 对于 img
      1. 懒加载：第一次加载页面的时候不要加载请求图片，哪怕它是异步的，也占据了 HTTP 并发数，导致其他资源延后加载
      2. base64：小图片使用 base64 格式，减少 HTTP 请求
  + Layout/Painting：重要的优化手段(减少DOM的"回流/重排"和重绘)
    - 第一次加载页面必然会有一次回流和重绘
    - 触发回流操作后，也必然会触发重绘；如果只触发重绘，则不会引发回流

DOM回流：这些操作都需要浏览器重新计算每一个元素在视口中的大小和位置(也就是回流Layout/Reflow)
  - 元素在视口中的大小和位置发生改变
  - 新增和删除元素(dispaly控制元素的显示隐藏)
  - 改变视口的大小
  - ...

当代浏览器的渲染队列机制：在当前上下文操作中，遇到一行修改样式的代码，并没有立即通知浏览器渲染，而是把其加入到渲染队列中，接下来看是否还有修改样式的代码，如果有，继续加入渲染队列中，一直到没有修改样式的代码或者遇到一行获取样式的代码，这些都会刷新浏览器的渲染队列机制

如何减少回流？

  1. 样式的读写分离：把修改样式的代码和读取样式的代码分离开
    - box.style.cssText = 'width:100px;height:100px;';
    - box.classList.add('xxx')
    - box.className = 'xxx'
  2. 缓存获取样式操作
  3. 新增多个元素使用 document.createDocumentFragment
  4. 把动画等频繁触发更改样式的操作，开启新的图层
  5. 修改元素的 transform/opacity 这些样式(浏览器硬件加速)