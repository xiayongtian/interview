{
  var x = 100
  function fn (y) {
    var x = 200
    return function(y) {
      console.log(y + x++)
    }
  }
  var f = fn()
  f(10)
  f(20)
}

{
  let x = 5
  function fn(x) {
    return function(y) {
      console.log(y + (++x))
    }
  }
  let f = fn(6)
  f(7)
  // f(7)
  fn(18)(9)
  f(10)
  console.log(x)
}

{
  let a = 0, b = 0
  function A(a) {
    A = function(b) {
      console.log(a + b++)
    }
    console.log(a++)
  }
  A(1)
  A(2)
}

// 简述你对闭包的理解，以及其优缺点？
// + 基本介绍：ECStack、EC、VO、AO、SCOPE、SCOPE-CHAIN、GC
// + 优缺点：保存和保护、性能消耗（内存泄露）
// + 实战应用：
//  - 项目实战应用：循环事件绑定（突出：事件委托）、let和var
//  - 插件组件封装：JS高级编程技巧（单例设计模式、惰性函数、科里化函数、compose组合函数）
//  - 源码阅读应用：lodash源码（函数的防抖和节流）、JQ源码、redux、react-redux（高阶组件）
//  - ...
// + 自己的思想和理解（一句话概括）

// 闭包的概念：在一个函数执行完后，它内部的变量会被释放，但是如果其他的函数有引用它内部的变量，就形成了闭包
// 闭包的优点：
//    1. 读取另一个函数作用域中的变量。
//    2. 保存数据，因为闭包的数据不会被释放，所以可以保存数据
//    3. 封装对象的私有属性和私有方法(对外提供访问数据的接口)
// 闭包的缺点：过度使用闭包可能会导致内存占用过多的问题，在IE浏览器中可能会导致内存泄露
// 产生闭包的场景：
//    1. 立即执行函数(IIFE)
//    2. 返回一个函数
//    3. 定时器、事件监听、AJAX请求等的回调
//    4. 作为函数参数传递
// 闭包的应用：早期的模块化(IIFE)、防抖节流(返回一个函数)、科里化函数(返回一个函数)、compose组合函数(返回一个函数)、循环事件绑定

// 简述 let 和 var 的区别？
// + var 定义的变量会进行变量提升
// + var 声明的变量可以重复声明
// + let 有暂时性死区(let 定义变量，在定义之前不能访问)
// + let 块级作用域
// + ...


